"""
Fundamental Gaussian Beam Propagation
Physics: 
- Gaussian beams are solutions to the paraxial wave equation
- Key parameters: wavelength, beam waist (w0), Rayleigh range (zR)
- Intensity profile: I(r) = I0 * exp(-2r^2/w(z)^2)
- Beam width: w(z) = w0 * sqrt(1 + (z/zR)^2)
- Wavefront radius: R(z) = z * (1 + (zR/z)^2) → infinite at beam waist
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft, fftshift, ifft

# Initialize parameters 
wavelength = 1550e-9  # 1550 nm - standard telecom wavelength (low fiber attenuation)
beam_waist = 50e-6    # 50 μm beam waist (typical for integrated photonics)
x_range = 200e-6      # +-200 μm field of view
# z_positions = [0, 0.05, 0.1]  # Start, middle, end
fields = {}
focal_length = 0.05  # 5cm focal length (strong lens for visible effect)
z_positions = [0, 0.03, 0.05, 0.07, 0.1, 0.15]  # Added positions around lens
lens_position = 0.05  # Lens located at 5cm
defect_center = 0  # Center of beam (x=0)
defect_radius = 20e-6  # 20 micron dust particle

# Create coordinate system
x = np.linspace(-x_range, x_range, 500)

# Gaussian beam function (complex field)
def gaussian_beam(x, z, w0, wavelength):
    k = 2*np.pi/wavelength  # Wave number
    z_r = np.pi*w0**2/wavelength  # Rayleigh range (diffraction scale)
    
    # Complex beam parameter
    w_z = w0 * np.sqrt(1 + (z/z_r)**2) if z != 0 else w0      # Beam width at z
    R_z = z * (1 + (z_r/z)**2) if z != 0 else float('inf')    # Wavefront radius
    psi = np.arctan(z/z_r) if z != 0 else 0                   # Gouy phase shift
    
    # Electric field
    amplitude = w0/w_z * np.exp(-(x**2)/(w_z**2))
    phase = np.exp(-1*(k*z + k*x**2/(2*R_z) - psi))
    
    return amplitude * phase


# LENS FUNCTIONS 

def apply_thin_lens(field, x, wavelength, focal_length):
   
    # Applies a thin lens phase transformation
    # Physics: Creates quadratic phase delay to focus light
    # Formula: φ(x) = - (π * x²) / (λ * f)
    
    k = 2 * np.pi / wavelength
    lens_phase = np.exp(-1 * k * x**2 / (2 * focal_length))
    return field * lens_phase

def propagate_fresnel(field, x, wavelength, dz):
   
    # Fresnel diffraction for beam propagation
    # Uses Fourier transform for efficient calculation
    
    dx = x[1] - x[0]
    N = len(x)
    fx = np.fft.fftfreq(N, dx)  # Spatial frequencies
    
    # Fresnel transfer function
    H = np.exp(-1 * np.pi * wavelength * dz * fx**2)
    
    # Propagate via Fourier transform
    U_f = fft(field)
    U_new = ifft(U_f * H)
    return U_new

# DEFECT FUNCTIONS 

def add_dust_defect(field, x, defect_center, defect_radius):
   
    # Adds a dust particle defect (opaque disk)
    # param field: Complex optical field
    # param x: Position array
    # param defect_center: Center of defect (meters)
    # param defect_radius: Radius of defect (meters)
    # return: Modified field
    
    # Create mask (1 = transparent, 0 = opaque)
    mask = np.ones_like(x)
    distance = np.abs(x - defect_center)
    mask[distance < defect_radius] = 0  # Block light within defect radius
    
    return field * mask


# SIMULATION LOOP
# Calculate beam at different propagation distances

current_field = gaussian_beam(x, 0, beam_waist, wavelength)  # Start at z=0

for z in z_positions:
    # Propagate to next position
    dz = z - (list(fields.keys())[-1] if fields else 0)
    if dz > 0:
        current_field = propagate_fresnel(current_field, x, wavelength, dz)
    
    # Apply lens at designated position
    if abs(z - lens_position) < 1e-5:  # Floating point comparison tolerance
        current_field = apply_thin_lens(current_field, x, wavelength, focal_length)
        print(f"Applied lens at z={z*100:.1f}cm")
        current_field = add_dust_defect(current_field, x, defect_center, defect_radius)
    
    fields[z] = current_field.copy()

# VISUALIZATION

fig, axs = plt.subplots(2, len(z_positions), figsize=(14, 8), sharex=True)

for i, z in enumerate(z_positions):
    zR = np.pi * beam_waist**2 / wavelength
    beam_width = beam_waist * np.sqrt(1 + (z/zR)**2) * 1e6  # in microns
    
    # Intensity profile
    intensity = np.abs(fields[z])**2
    axs[0, i].plot(x*1e6, intensity, 'b-')
    axs[0, i].set_title(f'z = {z*100:.1f} cm\nBeam Width: {beam_width:.1f} μm')
    axs[0, i].set_xlabel('Position (μm)')
    axs[0, i].set_ylabel('Intensity')
    axs[0, i].grid(True, alpha=0.3)

    # Highlight defect region at lens position
    if abs(z - lens_position) < 1e-5:
        axs[0, i].fill_betweenx(
            [0, np.max(intensity)*1.1],
            (defect_center - defect_radius)*1e6,
            (defect_center + defect_radius)*1e6,
            color='red', alpha=0.2, label='Dust Defect'
        )
        axs[0, i].legend()
    
    # Phase profile
    axs[1, i].plot(x*1e6, np.angle(fields[z]), 'r-')
    axs[1, i].set_xlabel('Position (μm)')
    axs[1, i].set_ylabel('Phase (rad)')
    axs[1, i].grid(True, alpha=0.3)

plt.suptitle(f'Gaussian Beam with Lens and {defect_radius*1e6:.0f}μm Dust Defect\n'
             f'Wavelength: {wavelength*1e9} nm | Lens Focal Length: {focal_length*100:.1f} cm', 
             fontsize=16)
plt.tight_layout()
plt.show()


# DEFECT POSITION EXPERIMENT


defect_positions = [-75e-6, -30e-6, 30e-6, 75e-6]  # Positions in microns
defect_radius = 20e-6  # Fixed 20μm size
results = {}

for position in defect_positions:
    # Run simulation with current defect position
    fields = {}
    current_field = gaussian_beam(x, 0, beam_waist, wavelength)
    fields[0] = current_field.copy()
    
    for i in range(1, len(z_positions)):
        z_prev = z_positions[i-1]
        z_current = z_positions[i]
        dz = z_current - z_prev
        
        current_field = propagate_fresnel(current_field, x, wavelength, dz)
        
        if abs(z_current - lens_position) < 1e-5:
            current_field = apply_thin_lens(current_field, x, wavelength, focal_length)
            current_field = add_dust_defect(current_field, x, position, defect_radius)
        
        fields[z_current] = current_field.copy()
    
    results[position] = fields


# VISUALIZE POSITION EFFECTS

fig, axs = plt.subplots(len(defect_positions), len(z_positions), figsize=(20, 16))

for row, position in enumerate(defect_positions):
    fields = results[position]
    for col, z in enumerate(z_positions):
        intensity = np.abs(fields[z])**2
        axs[row, col].plot(x*1e6, intensity, 'b-')
        
        if abs(z - lens_position) < 1e-5:
            axs[row, col].fill_betweenx(
                [0, np.max(intensity)*1.1],
                (position - defect_radius)*1e6,
                (position + defect_radius)*1e6,
                color='red', alpha=0.2
            )
        
        axs[row, col].set_title(f'z={z*100:.1f}cm | Pos={position*1e6:.0f}μm')
        axs[row, col].set_xlabel('Position (μm)')
        axs[row, col].grid(True, alpha=0.3)
        
        if col == 0:
            axs[row, col].set_ylabel(f'Pos: {position*1e6:.0f}μm\nIntensity')

plt.suptitle('Effect of Defect Position on Beam Propagation', fontsize=20, y=0.95)
plt.tight_layout()
plt.show()


# INTERESTING COMBINATIONS

combinations = [
    {'size': 10e-6, 'position': 0, 'label': 'Small Central'},
    {'size': 40e-6, 'position': 0, 'label': 'Large Central'},
    {'size': 20e-6, 'position': 50e-6, 'label': 'Medium Offset'},
    {'size': 30e-6, 'position': -60e-6, 'label': 'Large Edge'}
]

results = {}
for combo in combinations:
    fields = {}
    current_field = gaussian_beam(x, 0, beam_waist, wavelength)
    fields[0] = current_field.copy()
    
    for i in range(1, len(z_positions)):
        z_prev = z_positions[i-1]
        z_current = z_positions[i]
        dz = z_current - z_prev
        
        current_field = propagate_fresnel(current_field, x, wavelength, dz)
        
        if abs(z_current - lens_position) < 1e-5:
            current_field = apply_thin_lens(current_field, x, wavelength, focal_length)
            current_field = add_dust_defect(
                current_field, x, 
                combo['position'], combo['size']
            )
        
        fields[z_current] = current_field.copy()
    
    results[combo['label']] = fields


# COMPARATIVE VISUALIZATION AT FOCUS

focus_z = 0.1  # Focus position
plt.figure(figsize=(12, 8))

for label, fields in results.items():
    intensity = np.abs(fields[focus_z])**2
    plt.plot(x*1e6, intensity, label=label, linewidth=2)

plt.title(f'Beam Profile at Focus (z={focus_z*100:.1f}cm) with Different Defects', fontsize=16)
plt.xlabel('Position (μm)')
plt.ylabel('Intensity')
plt.grid(True, alpha=0.3)
plt.legend()
plt.show()

